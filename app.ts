import { Bot as GrammyBot, GrammyError, HttpError, Context, session, SessionFlavor } from "grammy";
import * as dotenv from "dotenv";
import { AppDataSource } from "./src/data-source";
import { User } from "./src/entity/User";
import { extraInfo } from "./src/entity/ExtraInfo";
import { checkUserExist } from './util/existCheck'
import {bioKeyboard1, bioKeyboard2, yesNoKeyboard, sexKeyboard, shareLocation} from './util/keyboards'
import { CALLBACK } from "./util/callBackQuery";
import {msgUser} from './util/userProfile'
import { Location } from "./src/entity/Location";
dotenv.config();

interface FormSession {
  step: "askConsent" | "askName" | "askAge" | "extraInfo" | 'askLocation' | 'askSex'| 'askSexSearch' | 'searchProfiles' |null;
  chatId?: string;
  name?: string;
  age?: number;
  sex?: boolean;
  editing?: boolean;
  sexSearch?: boolean;
  editingComponent?: 'language' | 'zodiac' | 'height' | 'persType' | 'search' | 'education' | 'kids' | 'bio' | 'work' | 'pets' 
  | 'alcohol' | 'smoke' | 'gym' | 'food' | 'socMedia' | 'nightLive' | 'lovelang' | 'commStyle' | 'location' |null;
  editingProf: {
    status:boolean;
    languagesStatus?: string;
    zodiacStatus?: number;
    heightStatus?: number;
    persTypeStatus?: number;
    searchStatus?: number;
    educationStatus?: number;
    kidsStatus?: number;
    bioStatus?: string
    workStatus?: string;
    petsStatus?: string;
    alcoholStatus?: number;
    smokeStatus?: number;
    gymStatus?: number;
    foodStatus?: number;
    socMediaStatus?: number;
    nightLiveStatus?: number;
  }
}

type MyContext = Context & SessionFlavor<FormSession>;

const bot = new GrammyBot<MyContext>(process.env.BOT_API_TOKEN as string);



AppDataSource.initialize()
  .then(async () => {
    bot.use(
      session({
        initial: (): FormSession => ({ step: "askConsent" , editingProf: { status: false} }),
      })
    );

    const extraInfoRepo = AppDataSource.getRepository(extraInfo)
    bot.command("start", async (ctx) => {
        const editingProf = { status: false }
        const chatId = String(ctx.chat.id);
        if (await checkUserExist(ctx) === false) {
            ctx.session = { step: "askConsent", chatId ,editingComponent: null, editingProf };
            await ctx.reply("–ü—Ä–∏–≤–µ—Ç! –¢–≤–æ—è –∞–Ω–∫–µ—Ç–∞ –Ω–µ –±—ã–ª–∞ –Ω–∞–π–¥–µ–Ω–∞. –î–∞–≤–∞–π —Å–æ–∑–¥–∞–¥–∏–º –µ—ë (–î–∞/–ù–µ—Ç)",{reply_markup: yesNoKeyboard} );
        } else {
            ctx.session.step = null
            await ctx.reply("–£ –≤–∞—Å —É–∂–µ –ø—Ä–æ–π–¥–µ–Ω–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è.\n\n–ï—Å–ª–∏ –≤—ã –∂–µ–ª–∞–µ—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å –∞–Ω–∫–µ—Ç—É, –Ω–∞–±–µ—Ä–∏—Ç–µ\n /edit\n \n–ï—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –ø–æ–∏—Å–∫ –Ω–∞–±–µ—Ä–∏—Çe\n /search");
        }
    });

    bot.command('edit', async (ctx) => {
        ctx.session.editing = true
        const chatId = String(ctx.chat.id)
        ctx.reply(await msgUser(ctx), {
            reply_markup: bioKeyboard1
        }) 
    })
    bot.on('callback_query', async (ctx) => {
        const chatId = String(ctx.chat.id)
        if(ctx.session.editing === true){
            let user = await AppDataSource.manager.findOneBy(User, { chatId })
            const extraInfRepo = AppDataSource.getRepository(extraInfo);
            let extra = await extraInfRepo.findOneBy({ chatId })

            if (!extra) {
              const extra = new Location();
              extra.chatId = user.chatId
              extra.user = user;
              await extraInfRepo.save(extra)
            }

          if(ctx.callbackQuery.data === 'delete'){
            const comp = ctx.session.editingComponent;
            let key = false;
            (comp === 'language')? await extraInfoRepo.update({ chatId }, { languages: null }) : void 0;
            (comp === 'zodiac')? await extraInfoRepo.update({ chatId }, { zodiacsign: null }) : void 0;
            (comp === 'height')? await extraInfoRepo.update({ chatId }, { height: null }) : void 0;
            (comp === 'persType')? await extraInfoRepo.update({ chatId }, { perstype: null }) : void 0;
            (comp === 'search')? await extraInfoRepo.update({ chatId }, { mysearch: null }) : void 0;
            (comp === 'education')? await extraInfoRepo.update({ chatId }, { education: null }) : void 0;
            (comp === 'kids')? await extraInfoRepo.update({ chatId }, { kidswish: null }) : void 0;
            (comp === 'bio')? await extraInfoRepo.update({ chatId }, { text: null }) : void 0;
            (comp === 'commStyle')? await extraInfoRepo.update({ chatId }, { commstyle: null }) : void 0;
            (comp === 'lovelang')? (await extraInfoRepo.update({ chatId }, { lovelang: null }), key = true) : void 0;
            (comp === 'work')? (await extraInfoRepo.update({ chatId }, { work: null }), key = true) : void 0;
            (comp === 'pets')? (await extraInfoRepo.update({ chatId }, { pets: null }), key = true) : void 0;
            (comp === 'alcohol')? (await extraInfoRepo.update({ chatId }, { alcohol: null }), key = true) : void 0;
            (comp === 'smoke')? (await extraInfoRepo.update({ chatId }, { smoke: null }), key = true) : void 0;
            (comp === 'gym')? (await extraInfoRepo.update({ chatId }, { gym: null }), key = true) : void 0;
            (comp === 'food')? (await extraInfoRepo.update({ chatId }, { food: null }), key = true) : void 0;
            (comp === 'socMedia')?(await extraInfoRepo.update({ chatId }, { socmedia: null }), key = true) : void 0;
            (comp === 'nightLive')? (await extraInfoRepo.update({ chatId }, { nightlive: null }), key = true) : void 0;
            ctx.deleteMessage()
            if(key){
              ctx.reply(await msgUser(ctx), {
                reply_markup: bioKeyboard2
              })
            } else {
              ctx.reply(await msgUser(ctx), {
                reply_markup: bioKeyboard1
              })
            }
            ctx.session.editingComponent = null
          }
            ctx.answerCallbackQuery('–£–∂–µ —Ä–∞–±–æ—Ç–∞—é!')
            await CALLBACK(ctx)
        }
    })
    
    
    bot.on("message:text", async (ctx) => {

      const text = ctx.message.text.trim();
      const chatId = String(ctx.chat.id);
      let user = await AppDataSource.manager.findOneBy(User, { chatId });
      if (!user) {
        user = new User();
        user.chatId = chatId;
      }
        const extra = new extraInfo()
        extra.chatId = user.chatId
        extra.user = user

      if(ctx.session.editing === true){
        if(ctx.session.editingComponent === 'language'){
          
          if(ctx.message.text.length > 35 ){
            ctx.reply('–ù–∞–ø–∏—à–∏ –∫–æ—Ä–æ—á–µ')
            return
          }
          ctx.deleteMessage()
          ctx.session.editingProf.languagesStatus = ctx.message.text
          extra.languages = ctx.message.text
          await extraInfoRepo.update({ chatId }, { languages: ctx.message.text })
          ctx.reply(await msgUser(ctx), {
            reply_markup: bioKeyboard1
          })
          
          ctx.session.editingComponent = undefined
          return void 0;
        }
        if(ctx.session.editingComponent === 'height'){
          if(isNaN(Number(ctx.message.text))){
            ctx.reply("–ù–∞–ø–∏—à–∏ —Ü–∏—Ñ—Ä—É")
            return
          }
          ctx.deleteMessage()
          ctx.session.editingProf.heightStatus = Number(ctx.message.text)
          extra.height = Number(ctx.message.text)
          await extraInfoRepo.update({ chatId }, { height: Number(ctx.message.text) })
          ctx.reply(await msgUser(ctx), {
            reply_markup: bioKeyboard1
          })
          ctx.session.editingComponent = undefined
          return void 0
        }
      }
      switch (ctx.session.step) {
        case "askConsent":
          if (text.toLowerCase() === "–¥–∞") {
            ctx.react('‚ù§‚Äçüî•')
            ctx.session.step = "askName";
            await ctx.reply("–û—Ç–ª–∏—á–Ω–æ! –ù–∞–ø–∏—à–∏ —Å–≤–æ—ë –∏–º—è:");
          } else {
            ctx.react('üíî')
            await ctx.reply("–•–æ—Ä–æ—à–æ, –µ—Å–ª–∏ –ø–µ—Ä–µ–¥—É–º–∞–µ—à—å ‚Äî –Ω–∞–ø–∏—à–∏ /start.");
            ctx.session.step = null;
          }
          break;
        case "askName":
          ctx.session.name = text
          if (ctx.session.name.length >= 25){
            await ctx.reply('–ò–º—è —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ')
            return
          }
          ctx.session.step = "askAge"
          await ctx.reply("–¢–µ–ø–µ—Ä—å –Ω–∞–ø–∏—à–∏ –≤–æ–∑—Ä–∞—Å—Ç:")
          break;
        case "askAge":
          const age = Number(text)
          if (isNaN(age)) {
            await ctx.reply("–ù–∞–ø–∏—à–∏ —Ü–∏—Ñ—Ä—É.")
            return
          }
          ctx.session.age = age
          ctx.session.step = "askSex"
          await ctx.reply("–í—ã–±–µ—Ä–∏ –ü–æ–ª", {reply_markup: sexKeyboard})
          break;
        case "askSex":
          if(text != 'üëö' && text != 'üëï'){
            ctx.reply('–ü—Ä–æ—Å—Ç–æ –≤—ã–±–µ—Ä–∏',{reply_markup: sexKeyboard})
            return
          } else {
            (text=='üëï')?ctx.session.sex = true: void 0;
            (text == 'üëö')?ctx.session.sex = false: void 0;
            ctx.session.step = 'askSexSearch'
            ctx.reply('–ö—Ç–æ –¢–µ–±–µ –∏–Ω—Ç–µ—Ä–µ—Å–µ–Ω?',{reply_markup: sexKeyboard})
          }
          break;
        case 'askSexSearch':
          if(text != 'üëö' && text != 'üëï'){
            ctx.reply('–ü—Ä–æ—Å—Ç–æ –≤—ã–±–µ—Ä–∏',{reply_markup: sexKeyboard})
            return
          } else {
            (text=='üëï')?ctx.session.sexSearch = true: void 0;
            (text == 'üëö')?ctx.session.sexSearch = false: void 0;
            ctx.session.step = 'askLocation'
            ctx.reply('–û—Ç–ø—Ä–∞–≤—å —Å–≤–æ–µ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ', {reply_markup: shareLocation})
          }
          break;
        case "extraInfo":
            if (text.toLowerCase() === "–¥–∞") {
                ctx.react('üî•')
                ctx.session.step = "extraInfo";
                await ctx.reply("–û—Ç–ª–∏—á–Ω–æ! –î–∞–≤–∞–π –ø—Ä–æ–¥–æ–ª–∂–∏–º!");
                user.name = ctx.session.name;
                user.age = ctx.session.age;
                user.sex = ctx.session.sex;
                user.sexSearch = ctx.session.sexSearch;
                user.regPassed = true;
                await AppDataSource.manager.save(user)
                ctx.session.step = null
                ctx.reply(await msgUser(ctx), {
                    reply_markup: bioKeyboard1
                })
                ctx.session.editing = true
              } else {
                ctx.reply("–•–æ—Ä–æ—à–æ. –ö–∞–∫ –Ω–∏–±—É–¥—å –≤ –¥—Ä—É–≥–æ–π —Ä–∞–∑!")
                user.name = ctx.session.name;
                user.age = ctx.session.age;
                user.sex = ctx.session.sex;
                user.sexSearch = ctx.session.sexSearch;
                user.regPassed = true;
                ctx.session.editing = false
                await AppDataSource.manager.save(user)
                ctx.session.step = "searchProfiles"
                ctx.reply("–ê–Ω–∫–µ—Ç–∞ —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞!")
                //–¢—É—Ç –±—É–¥–µ—Ç –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è –ø–æ–∏—Å–∫
              }
            break;

        default:
          await ctx.reply("–Ø –Ω–µ –ø–æ–Ω—è–ª. –ù–∞–ø–∏—à–∏ /start");
      }
    });

    bot.on(':location', async (ctx) => {
      const chatId = String(ctx.chat.id)
      const { latitude, longitude } = ctx.message.location
      if(ctx.session.step == 'askLocation' || ctx.session.editingComponent == 'location'){
        const user = await AppDataSource.getRepository(User).findOneBy({ chatId });
        const locationRepo = AppDataSource.getRepository(Location);

        let location = await locationRepo.findOneBy({ chatId });

          if (!location) {
            location = new Location();
              location.chatId = chatId;
              location.user = user;
          }

        location.location = {
          type: "Point",
          coordinates: [longitude, latitude],
        };

        await locationRepo.save(location);
        await ctx.reply("–õ–æ–∫–∞—Ü–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞! üìç");
        (ctx.session.step == 'askLocation')?(ctx.session.step = 'extraInfo', await ctx.reply('–•–æ—á–µ—à—å –µ—â–µ —á—Ç–æ —Ç–æ –æ —Å–µ–±–µ –Ω–∞–ø–∏—Å–∞—Ç—å?',{reply_markup: yesNoKeyboard})): void 0;
        (ctx.session.editingComponent == 'location')?(ctx.session.editingComponent = null, ctx.reply(await msgUser(ctx), {reply_markup: bioKeyboard1})): void 0;
      }else {
        ctx.reply('–ó–∞—á–µ–º –º–Ω–µ –º–µ—Ç–∫–∞')
      }
    })

    bot.catch((err) => {
      const ctx = err.ctx;
      console.log(`Error while handling update ${ctx.update.update_id}`);
      const e = err.error;

      if (e instanceof GrammyError) {
        console.log("Error in request:", e.description);
      } else if (e instanceof HttpError) {
        console.log("Error in request", e);
      } else {
        console.log("Error undefined", e);
      }
    });

    bot.start();
  })
  .catch((error) => console.log(error));
